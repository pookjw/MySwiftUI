// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.16.14 clang-1700.3.16.4)
// swift-module-flags: -target arm64-apple-xros26.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature Macros -enable-experimental-feature ExtensionMacros -enable-experimental-feature IsolatedAny2 -enable-upcoming-feature InferSendableFromCaptures -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 7.0.83.1.501 -module-name AttributeGraph -package-name AttributeGraph
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
@_exported import AttributeGraph
@_exported import Swift

@frozen
@propertyWrapper
public struct WeakAttribute<T> {
    public var base: AttributeGraph.AGWeakAttribute
    public var wrappedValue: T? {
        get
    }
    
    @_alwaysEmitIntoClient public init(base: AttributeGraph.AGWeakAttribute) {
        self.base = base
    }

    public init()
}

@frozen
@propertyWrapper
@dynamicMemberLookup
public struct Attribute<T> {
    public var wrappedValue: T {
        get
    }

    @_hasStorage
    public var identifier: AttributeGraph.AnyAttribute {
        get
        set
    }

    public init<C: AttributeGraph.Rule>(_ rule: C) where C.Value == T
    public init<C: AttributeGraph.Rule>(_ rule: C, initialValue: T) where C.Value == T
    public init<C: AttributeGraph.StatefulRule>(_ rule: C) where C.Value == T
    public init<C: AttributeGraph.StatefulRule>(_ rule: C, initialValue: T) where C.Value == T

    // TODO: Inline 같음
    public init(value: T)
    // 이것도
    public init(type: T.Type)

    public init<C: AttributeGraph._AttributeBody>(body: Swift.UnsafePointer<C>, value: Swift.UnsafePointer<T>?, flags: AttributeGraph.AGAttributeTypeFlags, update: () -> (Swift.UnsafeMutableRawPointer, AttributeGraph.AnyAttribute) -> ())
    public init(identifier: AttributeGraph.AnyAttribute)

    public subscript<U>(keyPath keyPath: Swift.KeyPath<T, U>) -> AttributeGraph.Attribute<U> {
        get
    }

    public subscript<U>(dynamicMember keyPath: Swift.KeyPath<T, U>) -> AttributeGraph.Attribute<U> {
        get
    }

    public subscript<U>(offset body: (inout T) -> AttributeGraph.PointerOffset<T, U>) -> AttributeGraph.Attribute<U> {
        get
    }
}

public struct IndirectAttribute<T> {

}

public struct AnyRuleContext {
    public func valueAndFlags<T>(of: AttributeGraph.Attribute<T>, options: AttributeGraph.AGValueOptions) -> (value: T, flags: AGChangedValueFlags)
    public func changedValue<T>(of: AttributeGraph.Attribute<T>, options: AttributeGraph.AGValueOptions) -> (value: T, changed: Swift.Bool)
}

public struct RuleContext<T> {

}

public struct _External: Swift.CustomStringConvertible {
    public var description: Swift.String {
        get
    }
}

public struct External<T> {

}

public struct Focus<Key, Value> {

}

public struct Map<Key, Value> {

}

public struct PointerOffset<A, B> {

}

public struct AnyOptionalAttribute {

}

@frozen
@propertyWrapper
public struct OptionalAttribute<T> {
    public var wrappedValue: T? {
        get
    }

    public init()
    public init(_: AttributeGraph.Attribute<T>)
    public init(_: AttributeGraph.WeakAttribute<T>)
    public init(_: AttributeGraph.Attribute<T>?)
}

public protocol _AttributeBody {}

public protocol Rule : AttributeGraph._AttributeBody {
    associatedtype Value

    var value: Self.Value {
        get
    }

    static var initialValue: Self.Value? {
        get
    }
}

extension AttributeGraph.Rule {
    public static var initialValue: Self.Value? {
        get
    }

    public static func _update(_: UnsafeMutableRawPointer, attribute: AttributeGraph.AnyAttribute)

    public var context: AttributeGraph.RuleContext<Self.Value> {
        get
    }

    public static func _updateDefault(_: Swift.UnsafeMutableRawPointer)
}

extension AttributeGraph.Rule where Value : Swift.Hashable {
    public func cachedValue(options: AttributeGraph.AGCachedValueOptions, owner: AttributeGraph.AnyAttribute?) -> Self.Value
    public static func _cachedValue(options: AttributeGraph.AGCachedValueOptions, owner: AttributeGraph.AnyAttribute?, hashValue: Swift.Int, bodyPtr: Swift.UnsafeMutableRawPointer, update: () -> (Swift.UnsafeMutableRawPointer, AttributeGraph.AnyAttribute) -> ()) -> Swift.UnsafePointer<Self.Value>
    public func cachedValueIfExists(options: AttributeGraph.AGCachedValueOptions, owner: AttributeGraph.AnyAttribute?) -> Self.Value?
}

extension AttributeGraph.Rule {
    public var attribute: AttributeGraph.Attribute<Self.Value> {
        get
    }
}

public protocol StatefulRule : AttributeGraph._AttributeBody {
    associatedtype Value
}

public protocol ObservedAttribute : AttributeGraph._AttributeBody {
}

public protocol AttributeBodyVisitor {
}

extension AttributeGraph.AnyAttribute: Swift.Hashable {}

extension AttributeGraph.Graph {
    public func onUpdate(_ callback: @escaping () -> Swift.Void)
    public func onInvalidation(_ callback: @escaping (AttributeGraph.AnyAttribute) -> Swift.Void)
}

extension AttributeGraph.Graph {
    public func addTraceEvent<T>(_: Swift.UnsafePointer<Swift.Int8>, context: Swift.UnsafePointer<T>)
    public func addTraceEvent<T>(_: Swift.UnsafePointer<Swift.Int8>, value: T)
}
